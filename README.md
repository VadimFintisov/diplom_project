## Описание проекта 
Данная методика состоит из двух частей. 

Первая часть описывает действия, выполняемые разработчиком программы, написанной на языке сценариев, по вычислению контрольной суммы внедряемого скрипта, подписанию её валидным ключом разработчика и экспортированию открытого ключа для проверки подписи и расшифрования файла. 

Вторая часть описывает действия пользователя скрипта и включает в себя импортирование открытого ключа, предоставленного разработчиком, проверка подписи файла с эталонным значением контрольной суммы, расшифрование этого файла, вычисление контрольной суммы полученного скрипта и сравнение её с эталонным значением.

## Устанавливаемые пакеты

Для нормального функционирования всех утилит необходимо убедиться в том, что в операционной системе установлены следующие пакеты:

1)	libfuse-dev – содержит средства разработки файловой системы в пользовательском пространстве;
2)	pkg-config – система для управления флагами компиляции и ссы-лок библиотек, которая работает с командами «automake» и «autoconf»;
3)	gostsum – содержит утилиту для расчета контрольной суммы по алгоритму ГОСТ Р 34.11-2012 файлов «gostsum»;
4)	gnupg – содержит утилиту, необходимую для создания ключей, подписания файлов и проверки подписи «gpg»;
5)	libgost-dev – содержит заголовочные файлы и статические биб-лиотеки, необходимые для компиляции приложений, использующих «libgost»;
6)	libgpgme11 – оберточная библиотека, которая обеспечивает при-кладной интерфейс программирования для языка «C» для доступа к некото-рым функциям «GnuPG»;
7)	libgpgme11-dev – содержит заголовочные и иные файлы, необхо-димые для компиляции программ, использующих библиотеку «libgpgme11».

В случае, если какие-либо из вышеперечисленных пакетов	 отсутствуют в системе, либо установлены с ошибками, необходимо правильно установить их с помощью того же менеджера пакетов, используя при необходимости диск со средствами разработки к операционной системе Astra Linux Special Edition.

# Сборка модуля

Перейти в папку проекта

cd ~/projects/fusexmp

Собрать 
 
gcc -Wall fusexmp.c pkg-config fuse --cflags --libs -o fusexmp -lgpgme -lgpg-error -lgost 

# Активация fusexmp
Используя менеджер файлов, переходим в папку

projects/fusexmp

в которой находится исполняемый файл виртуальной файловой системы. 
Открываем терминал Сервис’->’Запустить терминал и монтируем виртуальную файловую систему в папку ~/mnt/fuse/

sudo ./fusexmp ~/mnt/fuse/ -o allow_other

Переходим в папку ~/mnt/  

cd ~/mnt

Выполняем команду

sudo su

для получения root прав и переходим в папку, где находится измененный скриптовый файл test.py

cd fuse/home/dytheadoct/apps

Просматриваем содержание этой папки:

ls 

Как видно, в этой же папке находятся файлы с хеш-суммой и цифровой подписью от оригинального скрипта – они будут использоваться для проверки подлинности файла test.py.
Запускаем "вредоносный" скрипт python3 test.py и получаем ошибку.
Чтобы увидеть причину, переходим в соответствующую папку

cd /var/log

и выводим содержимое файла syslog:

cat /var/log/syslog | grep  FUSE_SCRIPT

Видно, что fusexmp не позволил запустить скрипт из-за разницы в hash-суммах файлов.
Таким образом, внутри виртуальной файловой системы, созданной с помощью fusexmp, нельзя запустить изменённые и скриптовые файлы.

# Запуск недоверенных скриптов

Запускаем Мой компьютер, переходим в папку

Домашняя/apps.

В этой папке находится тестовый скрипт на питоне (он имитирует работу, например, какого-либо системного скрипта), файлы с его hash-суммой и электронной подписью.
Открываем терминал
Сервис->Запустить терминал 

Запускаем тестовый скрипт:

python3 test.py

он выводит Hello, IT-Планета!
Закрываем терминал

# Подпись скриптов (первый этап)

1) В первую очередь необходимо открыть терминал. В терминале ввести команду для генерации ключа подписи, который будет использован для подписания файла с эталонным значением контрольной суммы:

sudo gpg --full-gen-key
 
2)	В списке выбора типа ключа необходимо выбрать вариант (15) GOST R34.10-2012 (sign only), для чего ввести «15» в терминале.
 
3)	В меню выбора срока действия ключа поставить необходимое значение, либо оставить по умолчанию (0), что будет означать неограниченный срок действия ключа. После этого будет выведена дата окончания срока действия ключа, либо написано, что срок действия ключа не ограничен. Если данные верны, вводите «Y», в противном случае вводите «N» и меняете значение срока действия ключа.
 
4)	В следующем пункте создания ключа необходимо ввести ID пользователя. Утилита создаст его из Вашего имени, комментария и адреса электронной почты, которые вы введете. Например: «Ivanov (Ivan Ivanovich) <ivanov@mail.ru>». Соответственно сначала будет предложено ввести Ваше настоящее имя, затем адрес электронной почти и в конце комментарий. После этого на экран будет выведена строка наподобие той, которая была в примере, только с введенными Вами данными. Проверяете правильность ввода. Если какой-то из пунктов введен неверно, его можно изменить, введя соответствующие буквы латинского алфавита: «N» – имя, «C» – комментарий, «E» – адрес электронной почты. Если же все введено верно, то подтверждаете свой выбор, введя «О». Если вы ходите выйти из программы создания ключа, введите «Q».
 
5)	Следующий пункт – создание пароля для защиты закрытого ключа. Именно этот пароль будет использоваться для расшифрования данных закрытого ключа, которые впоследствии будут записаны в файл. После ввода пароля Вам будет предложено подтвердить пароль, пароль необходимо ввести повторно.
6)	Следующим шагом программа начнет генерацию случайных чисел для получения достаточного количества энтропии для дальнейшего создания Вашего ключа. Этот процесс довольно длительный. Чтобы ускорить его, программа предлагает Вам выполнять некоторые действия: печать на клавиатуре, движение мыши, обращение к дискам.
 
7)	После завершения процесса генерации случайных чисел, программа выдаст итоговую информацию по созданию ключа. Если данный ключ первый, который был создан в системе, то программа создаст таблицу доверия, и внесет в нее этот ключ как абсолютно доверенный. Далее программа напишет, что открытый и закрытый ключи созданы и подписаны. Теперь их можно будет найти в директории: 

/root/.gnupg/

где открытый ключ будет содержаться в файле «pubring.gpg», а закрытый – в файле «secring.gpg». После этого программа выведет информацию о том, что в таблице доверия один подписанный ключ и выведет его идентификатор, дату создания, отпечаток и ID пользователя, который создал этот ключ.
 
8)	Следующим шагом будет расчет контрольной суммы используемого скрипта с помощью утилиты «gostsum». Чтобы рассчитать контрольную сумму данной утилитой и сохранить значение в файл, необходимо ввести команду:

gostsum *название файла* > *название выходного файла*

gostsum test.py > test.py.hash

9)	После создания файла с рассчитанным хешем скрипта его необходимо подписать созданным ключом. Сделать это можно с помощью команды:

gpg --sign *имя файла с хешем*

В случае, если в системе несколько ключей для подписания и тот ключ, которым Вы собираетесь подписать скрипт не является ключом по умолчанию для подписывания, то необходимо задать ID пользователя, ключом которого Вы хотите подписать скрипт:

gpg -u *ID пользователя* --sign *имя файла с хешем*
 
Утилита потребует пароль для доступа к закрытому ключу пользователя, создавшего данный ключ. Необходимо ввести пароль, который был задан на этапе создания ключа. Если пароль введен верно, то файл будет подписан, в противном случае утилита сообщит, что введен неверный пароль и предложит попробовать ввести пароль еще раз. 
После этого появится подписанный файл в формате *имя файла с хешем*.gpg, который будет содержать данные самого файла с хешем в зашифрованном виде.
Разработчик должен предоставить пользователю вместе с созданным приложением, написанным на языке сценариев, свой открытый ключ для проверки валидности подписи. Чтобы экспортировать ключ, необходимо воспользоваться командой:

gpg --export --output *выходной файл* *ID ключа*
 
На этом первая часть методики заканчивается. 

# Подпись скриптов (второй этап)

Следующий этап – настройка виртуальной файловой системы и запуск через нее скрипта разработчика с проверкой валидности подписи разработчика и сравнения высчитанного хеша приложения с «эталонным». На машине пользователя необходимо установить соответствующие библиотеки для работы с виртуальной файловой системой, подсчитывания контрольной суммы и верификации подписи разработчика.

1)	В первую очередь администратор должен импортировать открытый ключ разработчика в свою базу ключей. Для этого необходимо воспользоваться командой:

gpg --import *имя открытого ключа разработчика* 
 
2)	Чтобы расшифровать подписанный файл и сохранить расшифрованные данные в выходной файл, необходимо воспользоваться командой:

gpg --decrypt *имя подписанного файла* > *имя выходного файла*
 
Утилита «gpg» сама подберет необходимый открытый ключ для расшифрования, расшифрует и поместит расшифрованные данные в вы-ходной файл.

3)	Следующий шаг – вычисление контрольной суммы полученного файла со скриптом. Сделать это можно по уже известной из первой части методики команды:

gostsum *название файла* > *название выходного файла*

4)	После этого необходимо сравнить полученную в результате расчета контрольную сумму скрипта с эталонным значением контрольной суммы с помощью любых удобных средств. В случае, если хеши совпадают, значит скрипт действительный, не модифицированный и с ним можно работать, иначе его запуск запрещен.

Вторая часть методики предполагает собой автоматизацию с помощью виртуальной файловой системы, разворачиваемой с помощью средства разработки «libfuse-dev». Необходимо сконфигурировать программный код приложения FUSE таким образом, чтобы все действия, описанные во второй части методики происходили прозрачно для пользователя и минимально влияли на общую производительность.

# Описание принципов функционирования разработанного программного обеспечения

В начале работы администратор должен загрузить приложение с необходимыми параметрами. Всего при запуске выделяется три основных параметра: точка монтирования, режим работы приложения, режим работы алгоритма хэширования по ГОСТ Р 34.11-2012.

Первым параметром является точка монтирования. 

Это определенная директория в файловой системе, которая будет использоваться для монтирования файловой системы в пользовательском пространстве. Главное требование к этой директории в том, что она должна быть пустой. Администратору системы необходимо настроить разграничение доступа для администраторов и пользователей приложений таким образом, чтобы они имели доступ только к примонтированной области и не имели доступа к реальной файловой системе. В противном случае приложение FUSE не сможет перехватывать запросы на доступ к файлам.

Вторым параметром является режим работы приложения.

Всего реализовано два режима работы: нормальный и усиленный. По-умолчанию, в приложении задан нормальный режим работы. Это означает, что проверка целостности файлов происходит только при чтении программной первого блока данных запрашиваемого файла. Однако в данном режиме работе есть уязвимость: если нарушитель сумеет внедриться в процесс поблочного чтения данных запрашиваемого файла и заменить содержимое, то программа не выдаст ошибки о том, что файл был скомпрометирован. 
При усиленном режиме работы целостность файла проверяется при чтении каждого блока данных запрашиваемого файла. Это сильно влияет на временной ресурс, так как контроль целостности файла довольно длительный процесс. В качестве примера можно выбрать файл размером 10 мегабайт. Стандартный блок данных равен 65536 байтам. В начале процесса поблочного считывания данных считывается один блок, далее по два блока. При этом контроль целостности будет выполнен более 70 раз. Исходя из этого, можно установить ограничение: если объем запрашиваемых файлов не превышает 65536 байт, то выбор режима работы программы не имеет значения.
Выбор режима работы программы администратором определяется на основании критичности циркулируемой в системе информации, которая должна проходить проверку целостности.

Помимо выбора режима работы необходимо выбрать режим работы алгоритма хэширования, описанного в ГОСТ Р 34.11-2012, с хэш-кодом 256 бит или 512 бит. По умолчанию приложение работает в первом режиме, когда размер хэш-кода равен 256 битам. При выборе режима работы алгоритма хэширования администратор должен учитывать, какой алгоритм хэширования выбрал разработчик для создания файла с эталонным значением хэш-кода.
При монтировании приложения FUSE в указанную точку монтирования в первую очередь происходит инициализация файла с шаблонами регулярных выражений для фильтрации и файла с ключом для проверки валидности электронной подписи.
Инициализация файла с шаблонами регулярных выражений происходит с помощью функции regcomp библиотеки regex, которая была описана ранее. В случае успешной загрузки конфигурации, в системном журнале делается соответствующая запись, иначе выводится сообщение об ошибке. После чего начинается импортирование файла ключа, который будет использоваться для проверки электронной подписи. Проверку результата импортирования выполняет отдельная функция check_import_result, которая выводит в системный журнал сообщение об ошибке, если таковая имелась в результате выполнения импортирования.

После инициализации программа находится в режиме ожидания команды с запросом на файл.

На данном этапе необходимо учесть ограничение, что все три файла, участвующие в проверке – файл скрипта, файл с эталонным значением хэш-кода и файл подписи – должны находиться в одной директории. При этом название файла с эталонным значением хэш-кода должно быть такое же, как название файла скрипта, но с добавлением в конце «.hash», а название файла подписи должно быть такое же, как название файла с эталонным значением хэш-кода, но с добавлением в конце «.sig». Например, файл скрипта называется «good.py», значит, название файла с эталонным значением хэш-кода должно быть «good.py.hash», а файла с подписью – «good.py.hash.sig». При этом для защиты файлов от изменения администратору необходимо настроить разграничение прав доступа так, чтобы владельцем файла с эталонным значением хэш-кода и файла подписи было приложение FUSE и доступ был разрешен только на чтение. Всем другим субъектам системы доступ должен быть полностью закрыт.

Если пользователь или приложение формирует запрос на доступ к файлу, приложение FUSE перехватывает этот запрос и начинается этап фильтрации имени файла. Полный путь к файлу сравнивается со всеми заранее загруженными шаблонами регулярных выражений по очереди с помощью функции regexec из библиотеки regex, описанной ранее. При первом совпадении имени файла с каким-либо из шаблонов регулярных выражений, фильтрация заканчивается, и файл считается подлежащим фильтрации. В противном случае, если имя файла не совпало ни с одним из шаблонов регулярных выражений, файл признается не подлежащим проверке на целостность и доступ к нему разрешается.
Следующим этапом будет сравнение хэш-кодов, которое состоит из еще трех этапов: вычисление текущего значения хэш-кода, проверка подписи файла с эталонным значением хэш-кода и сравнение текущего значения хэш-кода с эталонным.

Первый этап – вычисление текущего значения хэш-кода. В зависимости от выбранного на этапе запуска режима работы алгоритма хэширования, описанного в ГОСТ Р 34.11-2012, вычисляется текущее значение хэш-кода файла с помощью функций gost12_hash_file или gost12_hash_file_512, описанных в библиотеке libgost. Вычисленное значение помещается во временный массив, который будет в дальнейшем использоваться для сравнения значений текущего и эталонного хэш-кодов.

Следующий этап – проверка подписи файла с эталонным значением хэш-кода. Для этого используется функционал модуля GPGME, описанного ранее. В первую очередь с помощью стандартной функции сравнения memcmp сравниваются отпечаток открытого ключа, который был импортирован ранее, и отпечаток ключа подписи, который определяется в результате импортирования файла подписи в контекст модуля GPGME. В случае, если отпечатки не совпадают, подпись считается скомпрометированной и доступ к файлу запрещается с занесением в системный журнал соответствующей записи. Если же отпечатки совпадают, то с помощью функции gpgme_op_verify происходит проверка валидности подписи. В случае, если проверка прошла успешно, считается что подпись файла с эталонным значением хэш-кода валидна, значит, файл не был изменен. Следовательно, значение эталонного хэш-кода из файла считывается и заносится в буфер для дальнейшего сравнения с вычисленным значением хэш-кода.

Последний этап контроля целостности файла – сравнение значений вычисленного и эталонного хэш-кодов. На данном этапе происходит побитовое сравнение значений с помощью функции memcmp. В случае если значения не совпадают, доступ к файлу скрипта запрещается с выводом в системный журнал соответствующего сообщения об ошибке. Если же значения совпадают, то делается вывод о том, что проверка на целостность была пройдена успешно и доступ к файлу разрешается.
