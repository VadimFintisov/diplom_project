# Сборка модуля

Перейти в папку проекта
cd ~/projects/fusexmp

Собрать 
 
gcc -Wall new_fusexmp.c pkg-config fuse --cflags --libs -o fusexmp -lgpgme -lgpg-error -lgost 

# Активация fusexmp
Используя менеджер файлов, переходим в папку
projects/fusexmp

в которой находится исполняемый файл виртуальной файловой системы. 
Открываем терминал Сервис’->’Запустить терминал и монтируем виртуальную файловую систему в папку ~/mnt/fuse/

sudo ./fusexmp ~/mnt/fuse/ -o allow_other

Переходим в папку ~/mnt/  
cd ~/mnt

Выполняем команду
sudo su
для получения root прав и переходим в папку, где находится измененный скриптовый файл test.py

cd fuse/home/dytheadoct/apps

Просматриваем содержание этой папки:
ls 

Как видно, в этой же папке находятся файлы с хеш-суммой и цифровой подписью от оригинального скрипта – они будут использоваться для проверки подлинности файла test.py.
Запускаем "вредоносный" скрипт 
python3 test.py
и получаем ошибку.
Чтобы увидеть причину, переходим в соответствующую папку
cd /var/log

и выводим содержимое файла syslog:
cat /var/log/syslog | grep  FUSE_SCRIPT

Видно, что fusexmp не позволил запустить скрипт из-за разницы в hash-суммах файлов.
Таким образом, внутри виртуальной файловой системы, созданной с помощью fusexmp, нельзя запустить изменённые и скриптовые файлы.

# Запуск недоверенных скриптов

Запускаем Мой компьютер, переходим в папку
Домашняя/apps.

В этой папке находится тестовый скрипт на питоне (он имитирует работу, например, какого-либо системного скрипта), файлы с его hash-суммой и электронной подписью.
Открываем терминал
Сервис->Запустить терминал 

Запускаем тестовый скрипт:
python3 test.py

он выводит Hello, IT-Планета!
Закрываем терминал



1)	Описание общего принципа защиты скриптового файла
На сегодняшний день программы, написанные на языках сценариев, яв-ляются довольно распространенными компонентами программных комплек-сов автоматизированных систем. Язык сценариев - высокоуровневый язык с командами, описывающими действия, которые необходимо выполнить систе-ме. Сценарий или скрипт — это программа, имеющая дело с готовыми про-граммными компонентами.
Поскольку скрипты представляют из себя не исполняемые, а скорее тек-стовые файлы с набором команд, они сильно подвержены изменениям извне. Потенциальный нарушитель может нарушить работоспособность скрипта, ча-сто даже без какого-либо специального программного обеспечения для этого. И так как скрипты являются частью целых программных комплексов и могут содержать критический код, изменение которого может нарушить работоспо-собность всей системы, их необходимо защищать.
В данной методике рассматривается операционная система специально-го назначения Astra Linux Special Edition, так как она соответствует требова-ниям руководящих документов ФСТЭК России по 3-му классу защищенности СВТ и 2-му уровню контроля отсутствия недекларированных возможностей. Операционная система, в том числе, может использоваться при создании ав-томатизированных систем до класса защищенности 1Б включительно.
Для осуществления защиты программ, написанных на языках сценариев, будет использоваться виртуальная файловая система, которую можно реали-зовать с помощью утилиты «libfuse-dev», которая входит в комплект диска со средствами разработки к операционной системе Astra Linux Special Edition.
Идея защиты заключается в ограничении доступа пользователей к фай-ловой системе путём развертывания виртуальной файловой системы с огра-ниченным доступом к файлам. Помимо этого, будет реализован механизм расчета контрольной суммы по алгоритму, описанному в ГОСТ Р 34.11-2012, с помощью встроенной утилиты «gostsum» и сравнение полученного значения с эталонным значением контрольной суммы, которое разработчик должен предоставить в подписанном виде вместе с файлом скрипта.

2)	Устанавливаемые пакеты: 
Данная методика состоит из двух частей. Первая часть описывает дей-ствия, выполняемые разработчиком программы, написанной на языке сцена-риев, по вычислению контрольной суммы внедряемого скрипта, подписанию её валидным ключом разработчика и экспортированию открытого ключа для проверки подписи и расшифрования файла. Вторая часть описывает действия пользователя скрипта и включает в себя импортирование открытого ключа, предоставленного разработчиком, проверка подписи файла с эталонным зна-чением контрольной суммы, расшифрование этого файла, вычисление кон-трольной суммы полученного скрипта и сравнение её с эталонным значением.
Для нормального функционирования всех утилит необходимо убедить-ся в том, что в операционной системе установлены следующие пакеты:

1)	libfuse-dev – содержит средства разработки файловой системы в пользовательском пространстве;
2)	pkg-config – система для управления флагами компиляции и ссы-лок библиотек, которая работает с командами «automake» и «autoconf»;
3)	gostsum – содержит утилиту для расчета контрольной суммы по алгоритму ГОСТ Р 34.11-2012 файлов «gostsum»;
4)	gnupg – содержит утилиту, необходимую для создания ключей, подписания файлов и проверки подписи «gpg»;
5)	libgost-dev – содержит заголовочные файлы и статические биб-лиотеки, необходимые для компиляции приложений, использующих «libgost»;
6)	libgpgme11 – оберточная библиотека, которая обеспечивает при-кладной интерфейс программирования для языка «C» для доступа к некото-рым функциям «GnuPG»;
7)	libgpgme11-dev – содержит заголовочные и иные файлы, необхо-димые для компиляции программ, использующих библиотеку «libgpgme11».

В случае, если какие-либо из вышеперечисленных пакетов	 отсутствуют в системе, либо установлены с ошибками, необходимо правильно установить их с помощью того же менеджера пакетов, используя при необходимости диск со средствами разработки к операционной системе Astra Linux Special Edition.
Следующим шагом будет реализация методики:
1)	В первую очередь необходимо открыть терминал. В терминале ввести команду для генерации ключа подписи, который будет использован для подписания файла с эталонным значением контрольной суммы:
Gpg --gen-key
 
2)	В списке выбора типа ключа необходимо выбрать вариант (12) GOST R34.10-2012 (sign only), для чего ввести «12» в терминале.
 
3)	В меню выбора срока действия ключа поставить необходимое значение, либо оставить по умолчанию (0), что будет означать неограничен-ный срок действия ключа. После этого будет выведена дата окончания срока действия ключа, либо написано, что срок действия ключа не ограничен. Если данные верны, вводите «y», в противном случае вводите «N» и меняете зна-чение срока действия ключа.
 
4)	В следующем пункте создания ключа необходимо ввести ID поль-зователя. Утилита создаст его из Вашего имени, комментария и адреса элек-тронной почты, которые вы введете. Например: «Ivanov (Ivan Ivanovich) <ivanov@mail.ru>». Соответственно сначала будет предложено ввести Ваше настоящее имя, затем адрес электронной почти и в конце комментарий. После этого на экран будет выведена строка наподобие той, которая была в примере, только с введенными Вами данными. Проверяете правильность ввода. Если какой-то из пунктов введен неверно, его можно изменить, введя соответству-ющие буквы латинского алфавита: «N» – имя, «C» – комментарий, «E» – ад-рес электронной почты. Если же все введено верно, то подтверждаете свой выбор, введя «О». Если вы ходите выйти из программы создания ключа, вве-дите «Q».

5. Следующий пункт – создание пароля для защиты закрытого ключа. Именно этот пароль будет использоваться для расшифрования данных закрытого ключа, которые впоследствии будут записаны в файл. После ввода пароля Вам будет предложено подтвердить пароль, следовательно, пароль необходимо ввести повторно.

6. Следующим шагом программа начнет генерацию случайных чисел для получения достаточного количества энтропии для дальнейшего создания Вашего ключа. Этот процесс довольно длительный. Чтобы ускорить его, программа предлагает Вам выполнять некоторые действия: печать на клавиатуре, движение мыши, обращение к дискам.

7. После завершения процесса генерации случайных чисел, программа выдаст итоговую информацию по созданию ключа. Если данный ключ первый, который был создан в системе, то программа создаст таблицу доверия, и внесет в нее этот ключ как абсолютно доверенный. Далее программа напишет, что открытый и закрытый ключи созданы и подписаны. Теперь их можно будет найти в директории: /root/.gnupg/, где открытый ключ будет содержаться в файле «pubring.gpg», а закрытый – в файле «secring.gpg». После этого программа выведет информацию о том, что в таблице доверия один подписанный ключ и выведет его идентификатор, дату создания, отпечаток и ID пользователя, который создал этот ключ.

8. Следующим шагом будет расчет контрольной суммы используемого скрипта с помощью утилиты «gostsum». Чтобы рассчитать контрольную сумму данной утилитой и сохранить значение в файл, необходимо ввести команду:
gostsum *название файла* > *название выходного файла*

9. После создания файла с рассчитанным хешем скрипта его необходимо подписать созданным ключом. Сделать это можно с помощью команды:
gpg --sign *имя файла с хешем*
В случае, если в системе несколько ключей для подписания и тот ключ, которым Вы собираетесь подписать скрипт не является ключом по умолчанию для подписывания, то необходимо задать ID пользователя, ключом которого Вы хотите подписать скрипт:
gpg -u *ID пользователя* --sign *имя файла с хешем*
Утилита потребует пароль для доступа к закрытому ключу пользователя, создавшего данный ключ. Необходимо ввести пароль, который был задан на этапе создания ключа. Если пароль введен верно, то файл будет подписан, в противном случае утилита сообщит, что введен неверный пароль и предложит попробовать ввести пароль еще раз. 
После этого появится подписанный файл в формате *имя файла с хешем*.gpg, который будет содержать данные самого файла с хешем в зашифрованном виде.
Разработчик должен предоставить пользователю вместе с созданным приложением, написанным на языке сценариев, свой открытый ключ для проверки валидности подписи. Чтобы экспортировать ключ, необходимо воспользоваться командой:
gpg --export --output *выходной файл* *ID ключа*
На этом первая часть методики заканчивается. 
Следующий этап – настройка виртуальной файловой системы и запуск через нее скрипта разработчика с проверкой валидности подписи разработчика и сравнения высчитанного хеша приложения с «эталонным». На машине пользователя необходимо установить соответствующие библиотеки для работы с виртуальной файловой системой, подсчитывания контрольной суммы и верификации подписи разработчика.

1) В первую очередь администратор должен импортировать открытый ключ разработчика в свою базу ключей. Для этого необходимо воспользоваться командой:
gpg --import *имя открытого ключа разработчика*

2) Чтобы расшифровать подписанный файл и сохранить расшифрованные данные в выходной файл, необходимо воспользоваться командой:
gpg --decrypt *имя подписанного файла* > *имя выходного файла*
Утилита «gpg» сама подберет необходимый открытый ключ для расшифрования, расшифрует и поместит расшифрованные данные в выходной файл.

3) Следующий шаг – вычисление контрольной суммы полученного файла со скриптом. Сделать это можно по уже известной из первой части методики команды:
gostsum *название файла* > *название выходного файла*

4) После этого необходимо сравнить полученную в результате расчета контрольную сумму скрипта с эталонным значением контрольной суммы с помощью любых удобных средств. В случае, если хеши совпадают, значит скрипт действительный, не модифицированный и с ним можно работать, иначе его запуск запрещен.

Вторая часть методики предполагает собой автоматизацию с помощью виртуальной файловой системы, разворачиваемой с помощью средства разработки «libfuse-dev». Необходимо сконфигурировать программный код приложения FUSE таким образом, чтобы все действия, описанные во второй части методики происходили прозрачно для пользователя и минимально влияли на общую производительность.
